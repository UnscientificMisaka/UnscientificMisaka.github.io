---
layout:     post
title:      "翻船的水沟，踩过的坑"
subtitle:   "函数"
date:       2017-03-18
author:     "LRZ"
header-img: "img/17-3-17.jpg"
tags:
    - Javascript
---

>随手总结一下学习过程中遇到的一些坑坑洼洼

#### 1.让伪数组可以使用数组的方法

<b>Array.prototype.slice.call(document.gMetElementsByTagName('*'));</b>

牛客上刷题时看见一同学讨论CVTE的前端编程题要求实现一个鼠标一上去浮现当前元素class名称。
顿时想到通过选取tag集合即可，刚写好调试但每次顺带弹出了html body script这些标签，想用数组的slice方法分割一下，又想到用call或apply可以动态改变this。本来是失败的因为学生只能想到用Array.prototype.call,但恰巧之前学习call和apply用法时看见过知乎某大神的讲解，需要在call前调用一次slice，因为选取出来的是类数组只有length,item这中属性，再用一下slice，slice的返回值就是一个数组，因此可以完美使用array中的所有方法。顺带涨了个知识，slice方法不带参数也是可以的，ES5中slice()如同slice(undefined),而underfined会被转换成0。

#### 2. js深浅拷贝
<b>var arr1 = arr2;</b>
切记不能直接赋值，这样两个数组引用相等，修改一个另一个也会变化。
常见的数组拷贝方法，迭代拷贝，slice浅拷贝，尤其要注意<b>splice的方法当插入使用时，不返回值，只有当删除功能使用时，才有返回值，并且返回值为其删除的数值</b>。有点前文不搭后文，做题目时调数组自带方法遇到这个梗。

#### 3. 安全的类型检测  

<b>function isArray(value){
  return Object.prototype.toString.call(value);
}</b>

typeof和instanceof并不很可靠，typeof null会返回object，低版本不同了浏览器检测正则会返回function或Object,intstance在一个页面包含多个frame的情况下问题也很多,在任何值上调用Object.tosString都会返回object+构造函数名。

3.27 update:js中String的初始化方式有两种，var str = "test"和var test = new String("test");这时候我们对new的方式typeof会返回object。

#### 4. Hoisting机制
<b>本质是只提升声明部分</b>
no talking, show me the code

    var a;//变量声明提升在当前作用域顶端
    var a = 1;//声明部分提升，赋值部分不会提升
    var c = function(){}//同上，只提升变量名，不提升函数值
    funtion a(){}//函数名函数体全体提升，优先级比变量高，相同的变量名会被忽略

    var a = 1;
    (function() {
      console.log(a); // undefined
      var a = 2;
    })();


    //下面系统分析一题
    var foo = {n:1};
    (funtion(foo){
        console.log(foo.n);//1
        foo.n = 3;
        var foo = {n:2};
        console.log(foo.n);//2
      })(foo);
    console.log(foo.n)//3
    /*首先进行预编译，初始化全局变量foo,匿名函数，局部变量foo;
    然后代码从上而下，从左至右运行，全局变量赋值(该变量为对象，属于引用类型)，匿名函数传入参数，console1;
    由于存在foo局部变量，foo被重新赋值，因为是引用类型，全局变量被重新赋值；
    var foo = {n:2};foo在第一步变量提升至匿名函数作用域中顶部，但在现在才被赋值，所以console打印出2
    最后全局变量被改变打印3,若传进来的参数是变量则属于复制,修改并不会影响到全局变量*/

#### 5. 运算符优先级
错了好多遍，+ 的优先级高于三目运算符，小于括号。

#### 6. 双等号引起的类型转换过程
1. 首先看双等号前后有没有NaN，存在返回false。
2. 再看双等号前后有没有布尔，存在把布尔转成数字。
3. 接着看双等号前后有没有字符串，再分情况：若为对象，调用toString或valueOf转换，若为数字，字符串转数字，若为字符串直接比较，其他返回false。
4. 如果一个是数字，一个是对象，对象转换后比较，否则返回false。
5. null == undefined，undefined是派生自null值的，ECMA-262规定相等性测试返回true。
