---
layout:     post
title:      "Java常考知识点"
subtitle:    "期末复习一波"
date:       2016-12-15 20:08:00
author:     "LRZ"
header-img: "img/16-12-15.jpg"
tags:
    - Java
---

>虽然很自信，但还是稳一点比较好，据说考简答题较多...  

#### 1.什么是java虚拟机？java为什么是和平台无关的编程语言？  
java虚拟机是一个可执行java字节码的虚拟机进程，java源文件被编译成java虚拟机执行的字节码文件。因为java知道底层硬件平台的指令长度和其他特性。   
 
##### 2.JDK：java软件开发包，包含了JRE，编译器和其他工具，可以让开发者开发编译执行java应用程序。    
JRE：java运行环境，执行java程序的虚拟机。  
  
#### 3.static关键字  
成员变量或方法可以在没有被实例化时访问，不需要通过对象.属性这种格式访问。  
在static环境中访问非static变量？  
不可以，静态成员属于类变量，随着类的加载而加载到静态方法区的内存，非静态变量随着实例创建而创建。类加载优先于实例的创建，类加载时不一定有实例创建，没有实例创建就不能访问非static变量。  
  
#### 4.支持的数据类型  
byte short int long float double boolean char  
顺带提下，数组在创建时已经被赋予了默认值，整数类型(byte,short,int,long)的基本类型变量默认值是0，float是0.0f，double是0.0d，char是'\u0000'，boolean是false。  
  
#### 5.Overriding和Overloading   
方法覆盖必须要有相同的方法名，参数列表和返回类型，父类的方法不能为private，返回值类型小于等于父类，抛出的异常小于等于父类。  
方法重载在一个类中加载，方法名相同参数个数或类型不同，与返回值无关  

##### 6.抽象类和接口
抽象类有抽象方法也有非抽象方法。接口中所有的方法都是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
抽象类中可以包含非final的对象，接口中默认是final，成员函数默认是public
抽象方法不能有方法体。接口不能被实例化，抽象类也不可以，如果包含main方法可以引用。  

#### 7.多态  
		
	class A{  
		public fun1(){  
			System.out.println("a的fun1方法")；  
			fun2();  
		}

		public fun2(){
			System.out.println("a的fun2方法")
		｝
	}

	class B extends A{
		public fun1(String msg){//子类重写父类方法，向上转型后父类不能引用该方法
			System.out.println("b的fun1方法")
		}
		
		public fun1(){
			System.out.println("b的fun1方法")
		}

		public fun2(){//指向子类的父类引用调用fun2时，必定是调用该方法
			System.out.println("b的fun2方法");
		}
	}
	
	main中
	A a = new B();
	a.fun1();//调用子类B的fun1()方法
	
	//若子类B中未覆盖fun1方法
	a.fun1();//输出:a的fun1方法，b的fun2方法    
  

  
#### 8.线程状态
1.新建  
2.可运行：线程对象创建后，其他线程调用了该线程的start()方法。该状态的线程位于可运行的线程池中，等待被线程调度选中，获取CPU使用权。  
3.运行：可运行状态的线程获得了CPU时间片，执行程序代码。
4.阻塞：线程因某种原因放弃看CPU使用权，让出时间片，暂时停止运行。直到线程进入可运行状态，才有机会获得时间片转到运行状态，阻塞有三种：  
等待阻塞：运行的线程执行o.wait()方法，JVM会把线程放入等待队列中。  
同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，JVM会把该线程放入锁池中。  
其他阻塞：运行的线程执行Thread.sleep()或t.join()方法或发出I/O请求时，JVM会把线程置为阻塞状态，当sleep()状态超时，join()方法中止，I/O处理完毕时，线程重新转入可运行状态  
5.死亡：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。
![](http://i.imgur.com/3tgwfQO.png)  

#### 9.throw和throws
throw在程序中明确抛出异常只能跟一个，throws是方法可能抛出的异常的声明可以跟好多。   
 
#### 10.先这样...还有好多,IO,集合框架，多线程并发，网络等...


		






