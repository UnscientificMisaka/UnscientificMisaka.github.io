---
layout:     post
title:      "JavaScipt设计模式（一）"
subtitle:   "函数"
date:       2017-03-17
author:     "LRZ"
header-img: "img/17-3-17.jpg"
tags:
    - Javascript
---


## 函数
以前写代码受IFE上js基础练习上导师给的代码框架熏陶一直喜欢这样写：

    function a(){
        ...
    }

    function b(){
      ...
    }

    function init(){
      ...
    }
    init();


每次review高分答案觉得别人的代码甚是封装完美，自愧远远不如，但每次观摩所学学的都是凤毛麟角，应用到自身时常想不起来。今观本书方才看破。

#### 1. 通过对象收编    

    var CheckObject = function(){};
    CheckObject.checkName = function(){
      ...
    }
    CheckObject.checkPassword = function(){
      ...
    }
这样减少覆盖或被覆盖的风险，但团队中其他人想用这个对象方法比较麻烦，不能复制该对象，new的时候新对象没有继承这些方法。进阶如下，调用时返回新对象。  

    var CheckObject = function(){
      return {
        CheckName : function(){
          ...
        },
        checkPassword : function(){
          ...
        }
      }
    }
    var a = CheckObject();
    a.checkPassword();

我们可以再完善一下，使其更像一个类：

    var CheckObject = function(){
      this.checkName = function(){
        ...
      },
      this.checkPassword = function(){
        ...
      }
    }
    var a = new CheckObject();
    a.checkName();

这是需要通过关键字new来创建，但每次创建的时候新创建的对象都会对类上的this对象进行复制，很浪费资源，我们需要再进行完善：

    var CheckObject = function(){};
    CheckObject.prototype.checkName = function(){
      ...
    }
    CheckObject.prototype.checkPassword = function(){

    }

这样创建实例时，都会沿着原型链向上寻找，对象的方法都是同一个，但prototype敲了很多遍，我们可以继续优化：
    var CheckObject = function(){};
      CheckObject.prototype = {
        checkName : function(){
          ...
        },
        checkPassword : function(){
          ...
        }
      }
    var a = new CheckObject();
    a.checkName();
    a.checkPassword();

看上去号了很多，如果方法很多但每次调用要敲很多遍实例名称a,本着代码复用的原则，我们继续优化：

    var CheckObject = function(){};
    CheckObject.prototype = {
      checkName : function(){
        ...
        return this;
      },
      checkPassword : function(){
        ...
        return this;
      }
    }
    var a = new CheckObject();
    a.checkName().checkPassword();

#### 2. 通过祖先添加
    Function.prototype.checkName = function(){
      ...
    }
    var f = function(){};//函数式
    var f = new Function();//类式
    f.checkName();
但是这样所有的函数都有了checkName的方法，又会浪费很多资源，所以我们需要抽象出一个统一添加的方法:  

    Function.prototype.addMethod = function(name,fn){
      this[name] = fn;//函数式
      //链式,但采用链式是调用不能直接使用必须要new
      this.prototype[name] = fn;
      return this;
    }
    var methods = new Function(){};
    methods.addMethod('checkName',function(){
      ...
    });
    methods.addMethod('checkPassword',function(){
      ...
    });
    methods.checkName();
    methods.checkPassword();
    //同样在每个函数体中return this,即可链式调用
    methods.checkName().checkPassword();

## 封装
#### 1. 通过块级作用域封装静态变量
js函数的块级作用域的存在提供了我们在类中创建私有变量的方法:  

        var Book = function(id,name,price){
          //私有属性
          var num = 1;
          //私有方法
          function checkId(){
            console.log("checkId");
          };
          //特权方法
          this.getName = function(){};
          this.getPrice = function(){};
          this.setName = function(){};
          this.setPrice = function(){};
          //公有属性
          this.id = id;
          //公有方法
          this.copy = function(){};
          //构造器
          this.setName(name);
          this.setPrice(price);
        }
        //实例化无法访问到类外.语法添加的属性
        Book.isChinese = true;
        Book.resetTime = function(){};
        //原型上定义的可以直接使用
        Book.prototype = {
          isJsBook : false,
          display : function(){}
        }

我们每次new一个Book的实例时，相当于执行一次Book,this定义的属性和方法可以复制到新的对象上，通过prototype创建的属性和方法也是可以访问到的，但类外通过点添加的属性或方法却不能访问。那么，如何看上去更像一个整体呢，我们可以试用闭包来实现。
#### 2. 通过闭包封装静态变量
JavaScipt高级程序设计一书中如是说：闭包是指有权访问一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

    var Book = (function(){
      //静态私有变量
      var num = 0;
      //静态私有方法
      function checkBook(name){}
      //创建类
      function book(newId,newName,newPrice){
          //私有变量
          var name,price;
          //私有方法
          function checkId(id){};
          //特权方法
          this.getName = function(){};
          this.getPrice = function(){};
          this.setName = function(){};
          this.setPrice = function(){};
          //公有属性
          this.id = newId;
          //公有方法
          this.copy = function(){};
          //构造器
          this.setName(name);
          this.setPrice(price);
      }
      //构建原型
      _book.prototype = {
        isJsBook : false,
        display : function(){}
      };
      return _book;
    })();
